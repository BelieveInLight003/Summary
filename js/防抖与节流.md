### 防抖

- 函数防抖的原理：在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。

```
function debounce(fn, wait, immediate) {
   let timer = null

   return function() {
       let args = arguments
       let context = this

       if (immediate && !timer) {
           fn.apply(context, args)
       }

       if (timer) clearTimeout(timer)
       timer = setTimeout(() => {
           fn.apply(context, args)
       }, wait)
    }
}
```

- 使用场景
  | 场景 | 原因 | 举例 |
  | --------------------- | --------------------------------------------- | ------------- |
  | **搜索框联想（input 实时搜索）** | 用户连续输入时，避免每次按键都发请求，只在用户**停止输入后**才发请求 | 百度/Google 搜索框 |
  | **窗口大小调整（resize）** | 用户拖动窗口大小时，resize 事件会高频触发，防抖可等用户**调整完成后**再重新布局 | 响应式布局重绘图表 |
  | **按钮防重复点击** | 防止用户**快速重复点击**按钮提交表单 | 提交订单、支付按钮 |
  | **搜索框输入验证** | 用户输入完邮箱/手机号后，**延迟验证**格式是否正确 | 注册表单 |

### 节流

- 函数节流的原理：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

```
function throttle(fn, wait, immediate) {
   let timer = null
   let callNow = immediate

   return function() {
       let context = this,
           args = arguments

       if (callNow) {
           fn.apply(context, args)
           callNow = false
       }

       if (!timer) {
           timer = setTimeout(() => {
               fn.apply(context, args)
               timer = null
           }, wait)
       }
    }
}
```

- 使用场景
  | 场景 | 原因 | 举例 |
  | --------------------- | ----------------------------- | -------------- |
  | **滚动监听（scroll）** | 滚动事件触发频率极高，节流可**降低处理频率**，提升性能 | 无限滚动加载、回到顶部按钮 |
  | **鼠标移动监听（mousemove）** | 鼠标移动事件触发频率极高，节流可**降低计算频率** | 拖拽预览、鼠标轨迹动画 |
  | **游戏或动画中的帧率控制** | 保证函数**固定频率执行**，避免性能问题 | 游戏中的射击冷却、动画帧更新 |
  | **窗口滚动时更新导航栏高亮** | 滚动页面时，**每隔一段时间**检测当前滚动位置 | 锚点导航高亮 |
